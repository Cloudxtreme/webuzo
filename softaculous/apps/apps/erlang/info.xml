<soft xmlns="http://www.softaculous.com">
	<overview>
		<img src="logo.gif" style="float:right;" alt="" />{{overview}}
	</overview>
	<features>
		{{features}}
	</features>
	<ratings>
		http://www.softaculous.com/sysapps/server_side_scripting/Erlang
	</ratings>
	<space>
		114311168
	</space>
	<support>
		http://www.erlang.org/
	</support>
	<version>
		N/A
	</version>
	<mod>1</mod>
	<softversion>
		4.1.9
	</softversion>
	<major>1</major>
	
	<sysrequires></sysrequires>
	
	<path name="bin">/usr/bin/erl</path>
		
	<notes>
		<center><font size="5" color="#182e7a">Erlang Environment :</font></center><br />
		<style>
.notestable td{
background: #E6F5FF;
}

.notestable th{
background: #EFEFEF;
}
		</style>
		<table border="0" cellspacing="1" cellpadding="8" align="center" class="notestable">
			<tr>
				<th>Desc</th>
				<th>Path</th>
			</tr>
			<tr>
				<td>Binary</td>
				<td>/usr/bin/erl</td>
			</tr>
			<tr>
				<td>Documentation</td>
				<td>http://www.erlang.org/doc.html</td>
			</tr>			
		</table>
	</notes>
	<languages>
		<english-overview>
		<font size="5" color="#182e7a">Erlang</font> is a programming language used to build massively scalable soft real-time systems with requirements on high availability. Some of its uses are in telecoms, banking, e-commerce, computer telephony and instant messaging. Erlang's runtime system has built-in support for concurrency, distribution and fault tolerance.
		<br /><br />
		Erlang is distributed under the <a href="http://www.erlang.org/EPLICENSE" target="_blank">ERLANG PUBLIC LICENSE</a>
		</english-overview>
		<english-features>			
		  <h1>built to kick ass</h1>		  
		  <p>Erlang was developed at <strong>Ericsson</strong> and was designed from the ground up for writing <strong>scalable</strong>, <strong>fault-tolerant</strong>, <strong>distributed</strong>, <strong>non-stop</strong>, <strong>soft-realtime</strong> applications. <em>Everything</em> in the language, runtime and libraries reflects that purpose, which makes Erlang the best platform for developing this kind of software.</p>		  
		  <p>Use Erlang if you want your application to:</p>		  
		  <ul>
			<li>handle very large number of concurrent activities</li>
			<li>be easily distributable over a network of computers</li>
			<li>be fault-tolerant to both software and hardware errors</li>
			<li>scale with the number of machines on the network</li>
			<li>be upgradable and reconfugurable without having to stop and restart</li>
			<li>be responsive to users within certain strict timeframes</li>    
			<li>stay in continuous operation for many years</li>
		  </ul>		  
		  <p>Because Erlang is oriented around concurrency, it's also naturally good at utilizing modern multicore systems.</p>		
		  <p>Lightweight concurrency transparent distribution hot code replacement, and OTP are some of the specific features that make Erlang a joy to work with.</p> 
		  <h1>battle-proven</h1>
		  <p>Erlang has been successfully used in production systems for over 20 years (with reported uptimes of 9-nines - that's 31ms of downtime a year). It's been proven to work well in both large-scale industrial software development, and in small agile teams in startups.</p>		
		  <p><strong>Ericsson</strong> themselves have used Erlang extensively for many projects of varying sizes, both commercial and internal. The AXD301 ATM, one of Ericsson's flagship products, may be the largest Erlang project in existence at over 1.1 million lines of Erlang.</p>		  
		  <p>Erlang users in the <strong>telecoms</strong> industry: Motorola, Nokia, T-Mobile, BT. <strong>Large software companies and startups</strong>: Amazon, Yahoo!, Facebook, Last.fm, Klarna, Tail-F, Github, Heroku, Engine Yard, MochiMedia. <strong>Open source projects</strong>: Flussonic, ejabberd, CouchDb, Riak, Disco, RabbitMQ, Dynomite.</p>
		  <h1>saves time and money</h1>		  
		  <p>Erlang lets you deliver kick-ass software faster, on smaller budgets and with smaller teams, and reduce TLC and TCO.</p>		  
		  <p>This is made possible by a number of reasons:</p>		  
		  <ul>
			<li>The OTP libraries provide a complete set of easy-to-use components for building robust distributed applications, that have been used in hundreds of projects, and thouroughly tested and debugged over the last 10 years.</li>
			<li>A large number of high-quality open-source libraries is available for many other tasks, such as XML processing or interacting with database systems such as PostgreSQL. Interfacing with existing code in Java, C, Python or Ruby is straightforward too.</li>
			<li>Erlang code tends to be conscise and readable, which is made possible by the simplicity of the language and powerful abstraction mechanisms available.</li>
			<li>Erlang scales well to large and small teams, and makes both top-down and bottom-up approaches to building software natural.</li>
			<li>Erlang is easy to learn. An experienced programmer can start writing useful code after a couple of days of learning Erlang.</li>
			<li>Availability of high-quality tools such as documentation generators, testing frameworks, debuggers, graphical diagnostics tools, and IDEs.</li>
		  </ul>  
		  <h1>easy to learn</h1>		  
		  <p>Erlang has a simple and consistent core which makes it easy to pick up. Experienced programmers can start writing useful code after a couple of days with Erlang. There are no complicated concepts to understand or arcane theories to master. The syntax may look a little different if you're coming from Ruby, Python, or Java, but it doesn't take long to get used to.</p>		  
		  <p>In fact, making the language easy to pick up was one of the original design goals of the Erlang development team. Erlang is very pragmatic and has been made by working programmers, for working programmers.</p>	
		  <h1>lightweight concurrency</h1>		  
		  <p>Processes are very lightweight, with only about 500 bytes of overhead per-process. This means that millions of processes can be created, even on older computers.</p>		  
		  <p>Because Erlang's processes are completely independent of OS processes (and aren't managed by the OS scheduler), your programs will behave in exactly the same way regardless of whether they run on Linux, FreeBSD, Windows or any of the other systems that Erlang runs on.</p>		  
		  <p>Because of Erlang's great support for concurrency it becomes natural to model applications around multiple independent communicating agents, which is just how things are in the real world.</p>	
		  <h1>hot code replacement</h1>		  
		  <p>In a real-time control system we often don't want to stop the system in order to upgrade the code. In certain real-time control systems we may never be able to turn off the system to perform upgrades, and such systems have to be designed with dynamic code upgrades in mind. An example of such system is the X2000 satellite control system developed by NASA.</p>		  
		  <p>When you write your app in Erlang, you get dynamic code upgrade support <em>for free</em> when you use <a href="#otp">OTP</a>. The mechanism itself is very straightforward and easy to understand.</p>		  
		  <p>This can save hundreds of hours of time in development:</p>		  
		  <p>This is a common Erlang development workflow:</p>		  
		  <ol>
			<li>Start the app.</li>
			<li>Edit the code.</li>
			<li>Recompile. (one keystroke)</li>
			<li>That's it! There is no restart step. The app gets updated with the new code while it's running and tests get run automatically to ensure there are no regressions. This of course works great with TDD too.</li>
		  </ol>		
		  <h1>transparent distribution</h1>		
		<p>Erlang programs can be easily ported from a single computer to a network of computers. With the exception of timing all operations in the distributed system will work in exactly the same way as they worked in a single-node system.</p>		
		  <h1>OTP</h1>		  
		  <p>OTP, the Open Telecom Platform, is a collection of standard libraries that distill years of real-world experience of building scalable, distributed, fault-tolerant applications.</p>
		</english-features>
	</languages>
</soft>